(* ::Package:: *)

(*BeginPackage["SeQuant`"];*)

(* Setting up internal things *)
Off[General::spell];
Off[General::spell1];
$RecursionLimit = 8192;
$IterationLimit = Infinity;
(*SetOptions[$FrontEnd,CommonDefaultFormatTypes->{"Output"->TraditionalForm}];*)
NCM = NonCommutativeMultiply;


(* ::Section:: *)
(* Global Parameters *)


(*
Special Operators
*)
Unprotect[defaultHamiltonianOpers];
Unprotect[ignoreDisconnectedOpers];
Unprotect[ignoreConnectedOpers];
defaultHamiltonianOpers = {"F","g","\!\(\*OverscriptBox[\(g\), \(_\)]\)"};
ignoreDisconnectedOpers = {};
ignoreConnectedOpers = {};
Protect[ignoreConnectedOpers];
Protect[ignoreDisconnectedOpers];
Protect[defaultHamiltonianOpers];


(*
Global SeQuant Parameters
*)
If[ !ValueQ[SeQuantDebugLevel],
    SeQuantDebugLevel = 0
];
SeQuantVacuumChoices["Physical"] = 0;
SeQuantVacuumChoices["SingleConfiguration"] = 1;
SeQuantVacuumChoices["MultiConfiguration"] = 2;

If[ !ValueQ[SeQuantVacuum],
    SeQuantVacuum = SeQuantVacuumChoices["SingleConfiguration"]
];


(* Definition of spaces *)
occ = particleSpace[occupied];
virt = particleSpace[virtual];
othervirt = particleSpace[othervirtual];
any = Union[occ,virt];
allvirt = Union[ virt,othervirt];
allany = Union[occ,allvirt];


spacesEqualIgnoreParticleType[a_particleSpace,b_particleSpace] :=
    (Select[a,Head[#]=!=particleType&]==Select[b,Head[#]=!=particleType&]); (* particleType defined but not used *)
spacesOverlapIgnoreParticleType[a_particleSpace,b_particleSpace] :=
    (Select[Intersection[a,b],Head[#]=!=particleType&]=!=particleSpace[]);
spacesOverlapIgnoreSpinAndParticleType[a_particleSpace,b_particleSpace] :=
    (Select[Intersection[a,b],Head[#]=!=particleType&&Head[#]=!=particleSpin&]=!=particleSpace[]);
spacesOverlap[a_particleSpace,b_particleSpace] :=
    (spacesOverlapIgnoreSpinAndParticleType[a,b] && Select[a,Head[#]===particleType&]===Select[b,Head[#]===particleType&]&& Select[a,Head[#]===particleSpin&]===Select[b,Head[#]===particleSpin&]);
(* return +1 if above, -1 if below, 0 if neither or both *)
spaceWRTFermiLevel[a_particleSpace] :=
    If[ spacesOverlapIgnoreSpinAndParticleType[a,allvirt],
        If[ spacesOverlapIgnoreSpinAndParticleType[a,occ],
            0,
            +1
        ],
        If[ spacesOverlapIgnoreSpinAndParticleType[a,occ],
            -1,
            0
        ]
    ];

(* Global index for most recently generated index 
Generated indices are named iXX, where i is generated by DefaultSpaceSymbol *)
GlobalIndexCounter = 0;
DefaultSpaceSymbol[occ] = "i";
DefaultSpaceSymbol[virt] = "a";
DefaultSpaceSymbol[allvirt] = "\[Alpha]";
DefaultSpaceSymbol[othervirt] = "\[Alpha]'";
DefaultSpaceSymbol[any] = "p";
DefaultSpaceSymbol[allany] = "\[Kappa]";


(* ::Section:: *)
(* particleIndex Class *)



(* create particleIndex with space and symbol i *)
createParticleIndex[i_String,space_particleSpace] :=
    Module[ {},
        particleIndex[i,space]
    ];
    
(* create particleIndex with DefaultSpaceSymbol *)
createParticleIndex[space_particleSpace] :=
    createParticleIndex[ToString[Subscript[DefaultSpaceSymbol[space],
    GlobalIndexCounter++],TraditionalForm],space];
    
(* takes A and replaces name and space with i and s, respectively *)
createParticleIndex[A_particleIndex,i_String,s_particleSpace] :=
    Module[ {},
        If[ Length[A]==3,
            particleIndex[i,s,A[[3]]],
            particleIndex[i,s]
        ]
    ];
    
(* if a has particleIndex b ignoring indexType *)
indexQ[a_,b_particleIndex] :=
    MemberQ[a,c_particleIndex/;(c[[1]]==b[[1]])&&(c[[2]]==b[[2]]),Infinity];

(* if particleIndex a has indexType[cre]*)
indexCreQ[a_particleIndex] :=
    MemberQ[a,indexType[cre]];
    
(* if particleIndex a has indexType[ann]*)
indexAnnQ[a_particleIndex] :=
    MemberQ[a,indexType[ann]];

(* if particleIndex a has indexType[bra]*)
indexBraQ[a_particleIndex] :=
    MemberQ[a,indexType[bra]];

(* if particleIndex a has indexType[ket]*)
indexKetQ[a_particleIndex] :=
    MemberQ[a,indexType[ket]];
    
(* return indexType of particleIndex with indexType *)
indexType[a_particleIndex] :=
    Cases[a,_indexType][[1,1]]
    
(* return particleSpace of particleIndex *)
indexSpace[a_particleIndex] :=
    Cases[a,_particleSpace][[1]];
    
(* return particleType of a particleIndex *)
indexParticle[a_particleIndex] :=
    Module[ {typeList},
        typeList = Cases[a[[2]],_particleType];
        If[ typeList=={},
            Return[particleType[default]],
            Return[typeList[[1]]]
        ]
    ];

(* return the symbol of particleIndex *)
indexSymbol[a_particleIndex] :=
    a[[1]];
    
(* remove indexType *)
indexLight[a_particleIndex] :=
    createParticleIndex[indexSymbol[a],indexSpace[a]];

(* if particleIndex equiv ignoring indexType *)
indexEquiv[a_particleIndex,b_particleIndex] :=
    (a[[1]]===b[[1]])&&(a[[2]]===b[[2]]);
    
(* given an index create a copy without its indexType *)
dropIndexType[a_particleIndex] :=
    If[ Length[a]=!=2,
        createParticleIndex[a[[1]],a[[2]]],
        a
    ];
    
dropIndexType[any_] :=
    any;

Unprotect[Equal];
Equal[a_particleIndex,b_particleIndex] :=
    (a[[1]]===b[[1]])&&(a[[2]]===b[[2]]);
Protect[Equal];

(* canonical ordering of particleIndex objects is defined as follows: order by particleSpace first, then alphabetically by the symbol *)
Unprotect[OrderedQ];
OrderedQ[A_particleSpace,B_particleSpace] :=
    If[ OrderedQ[A[[2]],B[[2]]],
        OrderedQ[A[[1]],B[[1]]],
        True
    ];
Protect[OrderedQ];

(* this functions throws out all multiple occurences of the same index from inds *)
uniqueIndexList[inds_List] :=
    Module[ {tmpinds,ind},

(* Old code *)
(*tmpinds={inds[[1]]};
Do[
ind=inds[[i]];
If[!indexQ[tmpinds,ind],
tmpinds=Append[tmpinds,ind]
],
{i,Length[inds]}
];*)

(* Union does it now *)
        tmpinds = Union[inds];
        Return[tmpinds];
    ];

(* "tag " and "untag " all indices in expr which also appear in intInds. uses indexQ *)
tagIndex[index_particleIndex] :=
    Append[index,mysecrettag[]];
tagIndex[expr_] :=
    expr;
untagIndex[index_particleIndex] :=
    DeleteCases[index,_mysecrettag];
untagIndex[expr_] :=
    expr;

tagIndices[expr_,inds_List] :=
    Module[ {result,ninds,pos,ind},
        ninds = Length[inds];
        result = expr;
        Do[
            ind = inds[[i]];
            pos = Position[result,c_particleIndex/;indexEquiv[c,ind]];
            result = MapAt[tagIndex,result,pos],{i,1,ninds}];
        Return[result];
    ];

untagIndices[expr_,inds_List] :=
    Module[ {result,ninds,pos,ind},
        ninds = Length[inds];
        result = expr;
        Do[
            ind = inds[[i]];
            pos = Position[result,c_particleIndex/;indexEquiv[c,ind]];
            result = MapAt[untagIndex,result,pos],{i,1,ninds}];
        Return[result];
    ];
    


(* ::Section:: *)
(* SQS Class *)


(*
SQS is a string of creation/annihilation operators
only normal ordered strings can be utilized at the moment
 *)
inorder = normalOrder[True];
noorder = normalOrder[False];
createSQS[creInds_List,annInds_List,norm_normalOrder:inorder] :=
    Module[ {},
        Return[flattenSQS[SQS[creInds,annInds,norm]]]
    ];
SQS::wrongdepth = "Argument has wrong depth";
flattenSQS[a_SQS] :=
    Module[ {nc,na,result,creInds,annInds,x},
        Off[Append::normal];
        If[ Depth[a]<5,
            Return[a]
        ];
        Clear[result];
        Clear[creInds];
        Clear[annInds];
        Clear[x];
        na = Length[a[[2]]];
        nc = Length[a[[1]]];
        creInds = Cases[a[[1]],x_particleIndex->Append[x,indexType[cre]]];
        annInds = Cases[a[[2]],x_particleIndex->Append[x,indexType[ann]]];
        result = FlattenAt[SQS[FlattenAt[{creInds,Reverse[annInds]},{{1},{2}}]],{1}];
        Return[result];
    ];

(* find all index types in a *)
indexTypesSQS[a_SQS] :=
    Module[ {ninds,ind,types,type},
        ninds = Length[a];
        types = {};
        Do[
            type = indexParticle[a[[ind]]];
            types = Append[types,type]
            ,{ind,1,ninds}
        ];
        types = Union[Flatten[types]];
        Return[types];
    ];

(* find the number of ptype operator in a *)
numIndicesOfType[a_SQS,ptype_particleType] :=
    Module[ {ninds,result},
        ninds = Length[a];
        result = 0;
        Do[
        	result+=If[ indexParticle[a[[i]]]===ptype,
                       1,
                       0
                    ]
           ,{i,1,ninds}
        ];
        Return[result];
    ];

(*Find the first index of ptype, else return -1*)
firstIndexOfType[a_SQS,ptype_particleType] :=
    Module[ {ninds,ind,index},
        ninds = Length[a];
        ind = -1;
        Do[
            index = a[[i]];
            If[ indexParticle[index]===ptype,
                ind = i;
                Break[]
            ]
           ,{i,1,ninds}
        ];
        Return[ind];
    ];

(* selects creation/annihilation indices from SQS *)
creIndices[a_SQS] :=
    Cases[a,x_particleIndex/;indexCreQ[x]->createParticleIndex[x[[1]],x[[2]]] ];
annIndices[a_SQS] :=
    Reverse[Cases[a,x_particleIndex/;indexAnnQ[x]->createParticleIndex[x[[1]],x[[2]]] ]];


(* ::Section:: *)
(*  SQM class  *)


(*
SQM is a matrix element of an operator
operators can be classified as antisymm, symm, and nonsymmetric, which will help in reducing expressions to their simplest form
 *)
antisymm = indexSymm[-1];
symm = indexSymm[1];
nonsymm = indexSymm[0];
createSQM[O_String,braInds_List,ketInds_List,symm_indexSymm:antisymm] :=
    Module[ {},
        Return[flattenSQM[SQM[O,braInds,ketInds,symm]]]
    ];
SQM::wrongdepth = "Argument has wrong depth";
flattenSQM[a_SQM] :=
    Module[ {nb,nk,result,braInds,ketInds,x},
        Off[Append::normal];
        If[ Depth[a]<5,
            Return[a]
        ];
        Clear[result];
        Clear[braInds];
        Clear[ketInds];
        Clear[x];
        nb = Length[a[[2]]];
        nk = Length[a[[3]]];
        braInds = Cases[a[[2]],x_particleIndex->Append[x,indexType[bra] ] ];
        ketInds = Cases[a[[3]],x_particleIndex->Append[x,indexType[ket] ] ];
        result = FlattenAt[SQM[FlattenAt[{braInds,ketInds},{{1},{2}}]],{1}];
        result = Prepend[result,OHead[a[[1]],a[[4]]]];
        Return[result];
    ];



(* ::Section:: *)
(* Visualize function *)


(* these functions display SQ expressions in tensor notation *)
visualizeSQE[a_*b_] :=
    visualizeSQE[a]*visualizeSQE[b];
visualizeSQE[a_**b_] :=
    visualizeSQE[a]**visualizeSQE[b];
visualizeSQE[a_^n_Integer] :=
    visualizeSQE[a]^n;
visualizeSQE[a_+b_] :=
    visualizeSQE[a]+visualizeSQE[b];
visualizeSQE[a_/;(Head[a]=!=SQS&&Head[a]=!=deltaIndex&&Head[a]=!=SQM)] :=
    a;
visualizeSQE[a_deltaIndex] :=
    Subsuperscript["\[Delta]",a[[1,1]],a[[2,1]] ];

visualizeSQE[a_SQS] :=
    Module[ {bodyLabel,nsup,nsub,inds,i},
(* convention labels strings normal-ordered wrt to nonphysical vacuum as tilde{a} *)
        bodyLabel = If[ SeQuantVacuum==SeQuantVacuumChoices["Physical"],
                        "a",
                        "\[ATilde]"
                    ];
        supInds = "";
        subInds = "";
        Do[
            If[ Cases[a[[i]],_indexType][[1,1]]===cre,
                supInds = StringJoin[supInds,a[[i,1]] ],
                subInds = StringJoin[a[[i,1]],subInds ]
            ],{i,1,Length[a] }
        ];
        Return[Subsuperscript[bodyLabel,subInds,supInds]]
    ];

visualizeSQE[a_SQM] :=
    Module[ {bodyLabel,nsup,nsub,inds,i},
        bodyLabel = a[[1,1]];
        supInds = "";
        subInds = "";
        Do[
            If[ indexKetQ[a[[i]]],
                supInds = StringJoin[supInds,a[[i,1]] ],
                subInds = StringJoin[subInds,a[[i,1]] ]
            ],{i,2,Length[a] }
        ];
        Return[Subsuperscript[bodyLabel,subInds,supInds]]
    ];

Format[deltaIndex[a__],TraditionalForm] :=
    visualizeSQE[deltaIndex[a]];
Format[SQM[a__],TraditionalForm] :=
    visualizeSQE[SQM[a]];
Format[SQS[a__],TraditionalForm] :=
    visualizeSQE[SQS[a]];



(* ::Section:: *)
(* Contraction functions *)


(*
Low-level contraction routines

contractIndex contracts 2 indices
contractSQS contracts a List of SQ strings of operators

deltaIndex is our representation of Kroneker delta
*)
contractIndex[L_particleIndex,R_particleIndex] :=
    Module[ {iL,iR,spaceL,spaceR,typeL,typeR, fermiL, fermiR,intIndex},
    	(* check if particles are the same *)
        typeL = Cases[L[[2]],_particleType];
        typeR = Cases[R[[2]],_particleType];
        If[ typeL=!=typeR,
            Return[0]
        ];
        (*if both creation or both annihilation - result is 0*)
        If[ L[[3]]==R[[3]],
            Return[0]
        ];

        (* the case of a multiconfiguration vacuum cannot be handled by simple Wick-type rules *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["MultiConfiguration"],
            Print["Wick theorem for MultiConfiguration vacuum is not expressed as simple contraction"];
            Abort[]
        ];
        (* discard zero contractions for the case of a determinant vacuum *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["SingleConfiguration"],
            fermiL = spaceWRTFermiLevel[L[[2]]];
            If[ L[[3]]==indexType[ann]&&fermiL==-1,
                Return[0]
            ];
            If[ L[[3]]==indexType[cre]&&fermiL==+1,
                Return[0]
            ];
            fermiR = spaceWRTFermiLevel[R[[2]]];
            If[ R[[3]]==indexType[cre]&&fermiR==-1,
                Return[0]
            ];
            If[ R[[3]]==indexType[ann]&&fermiR==+1,
                Return[0]
            ];
        ];
        (* discard zero contractions for the case of a physical vacuum *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["Physical"],
            If[ L[[3]]==indexType[cre],
                Return[0]
            ];
        ];
        If[ !spacesOverlap[L[[2]],R[[2]]],
            Return[0]
        ];
        If[ SeQuantDebugLevel>=5,
            Print["In contractIndex: ",L//TraditionalForm," and ", R//TraditionalForm]
        ];
        (* single-configuration contractions involving general (non-particle and non-hole) indices involve particle and hole density matrices *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["SingleConfiguration"]&&(fermiL==0&&fermiR==0),
            (* must be unoccupied *)
            If[ R[[3]]==indexType[cre],
                intIndex = createParticleIndex[allvirt];
                result = deltaIndex[Drop[L,{3}],intIndex ] *  deltaIndex[intIndex,Drop[R,{3}] ];
            ];
            (* must be occupied *)
            If[ R[[3]]==indexType[ann],
                intIndex = createParticleIndex[occ];
                result = deltaIndex[Drop[R,{3}],intIndex ] *  deltaIndex[intIndex,Drop[L,{3}] ];
            ];
            Return[result];
        ];
        If[ L[[1]]==R[[1]],
            Return[1]
        ];
        If[ R[[3]]===indexType[cre],
            Return[deltaIndex[Drop[L,{3}],Drop[R,{3}] ] ],
            Return[deltaIndex[Drop[R,{3}],Drop[L,{3}] ] ]
        ];
    ];

(* if a has member deltaIndex b *)
deltaQ[a_,b_deltaIndex] :=
    MemberQ[a,c_deltaIndex/;(indexQ[c,b[[1]] ]&&indexQ[c,b[[2]] ])];



(* ::Subsection:: *)
(* CR Class *)


(*
CR is the head for a general result of a contraction (unless it's a zero)
such a result consists of a prefactor and a noncommutative product of SQ strings:
CR[pfac,body]
*)
factorIntoCR[a_,0] :=
    0;
factorIntoCR[a_,b_CR] :=
    CR[a*b[[1]],b[[2]]];
factorIntoCR[a_,b:Plus[__]] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[b];
        Do[result+=factorIntoCR[a,b[[i]]],{i,1,nterms}];
        Return[result];
    ];
AddCR[a_CR,b_CR] :=
    CR[1,a+b];
    
(* returns c if it does not equal to t *)
uniqueCR[t_CR,c_CR] :=
    If[ t=!=c,
        c,
        0
    ];
    
(* returns members of c that do not equal to t *)
uniqueCR[t_CR,c_Plus] :=
    Module[ {uc},
        uc = 0;
        Do[uc+=uniqueCR[t,c[[i]]],
            {i,1,Length[c]}
        ];
        Return[uc];
    ];

(* returns c if it does not appear in t *)
uniqueCR[t_Plus,c_CR] :=
    If[ FreeQ[t,c],
        c,
        0
    ];

(* returns the terms in c that do not appear in t *)
uniqueCR[t_Plus,c_Plus] :=
    Module[ {uc},
        uc = 0;
        Do[uc+=uniqueCR[t,c[[i]]],
            {i,1,Length[c]}
        ];
        Return[uc];
    ];


(* ::Subsection:: *)
(*  Contract SQS  *)


(*

  If fullContract
    find the first index
    contract recursively, i.e. result = contraction[i,j]*contractSQS[str/ij]
  else
    loop over all pairs of indices i and j
       result += normalOrderedForm[str] + contraction[i,j]*contractSQS[str/ij]

*)
contractSQS[str:NCM[__SQS],ptype_particleType,contractOptions_List] :=
    Module[ {result,sqsL,sqsR,indexL,indexR,indL,indR,iR,indRoff,strLoff,contr1,contr2,newstr,sqsLlast,sqsLfirst,indLfirst,indLlast,newcontrib},
        If[ Depth[str]==2,
            Return[CR[1,1]]
        ];
        If[ SeQuantDebugLevel>=5,
            Print["called contract SQS for str=",str//TraditionalForm," ptype=",ptype//TraditionalForm]
        ];

        (*Recursively drop empty strings*)
        result = {};
        Do[
        	sqsL = sL;
        	If[ Length[str[[sL]]]==0,
            	result = contractSQS[Drop[str,{sL}],ptype,contractOptions ];
            	Break[]
        	],
        	{sL,1,Length[str]}
        ];
        If[ result=!={},
            Return[result]
        ];

        (*Cannot contract single string*)
        If[ Length[str]==1,
            result = If[ !(fullContract/.contractOptions),
                         CR[1,str[[1]]],
                         0
                     ];
            Return[result]
        ];
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: dropped all empty strings str=",str//TraditionalForm]
        ];

        (*Find the first string that has an index of ptype*)
        indRoff = 0;
        sqsL = -1;
        Do[
        
        	indL = firstIndexOfType[str[[sL]],ptype];
        	If[ indL!=-1,
            	sqsL = sL;
            	Break[]
        	],
        
        	{sL,1,Length[str]-1}
        ];
        
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: first substring that contains index of ptype = ",sqsL]
        ];

        (*exit if such string is not found*)
        If[ sqsL==-1,
            result = If[ (fullContract/.contractOptions),
                         0,
                         CR[1,str]
                      ];
            Return[result]
        ];

        (* If not doing full contraction, then first add the strings reordered into normal order (taking into account the signs) *)
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: ",(fullContract/.contractOptions)]
        ];
        
        result = If[ !(fullContract/.contractOptions),
                     normalOrderedForm[str,ptype],
                     0
                 ];

        (* Only one string needs to be considered if full contraction is sought *)
        sqsLfirst = sqsL;
        sqsLlast = If[ !(fullContract/.contractOptions),
                       Length[str]-1,
                       sqsL
                   ];
        Do[
        	sqsL = sL;
        	indL = firstIndexOfType[str[[sqsL]],ptype];
       		 If[ indL==-1,
            	Continue[]
        		];

        	(* only 1 index need to be considered if seeking a full contraction *)
        	indLfirst = indL;
        	indLlast = If[ !(fullContract/.contractOptions),
                       Length[str[[sqsL]]],
                       indL
                   	];

       	 	(* strLoff keeps track of the distance between the first ptype index in strL and the end of the string. It's used to initialize indRoff.
        	indRoff is the distance between left and right indices *)
        	strLoff = numIndicesOfType[str[[sqsL]],ptype];
        	Do[
        		indL = iL;
        		indexL = str[[sqsL,indL]];
        		If[ indexParticle[indexL]=!=ptype,
            		Continue[]
        		];
        		strLoff--;
        		indRoff = strLoff+1;
        		If[ SeQuantDebugLevel>=7,
            		Print["Chose left index: indexL = ",indexL//TraditionalForm," indRoff = ",indRoff];
        		];

        		(*Contract with every other index of ptype*)
        		Do[
        
       				 iR = 0;
        			Do[ 
        				indexR = str[[sqsR,indR]];
       					 If[ SeQuantDebugLevel>=7,
            				Print["Chose right index: indexL = ",indexL//TraditionalForm," indexR = ",indexR//TraditionalForm," indRoff = ",indRoff];
       					 ];
        				If[ indexParticle[indexR]=!=ptype,
           					 Continue[],
           					 iR+=1
       					 ];
       					 If[ SeQuantDebugLevel>=5,
            				Print["Calling contractIndex for ",indexL//TraditionalForm," and ", indexR//TraditionalForm]
        				 ];
        				contr1 = contractIndex[indexL,indexR];
        				If[ SeQuantDebugLevel>=5,
            				Print["result = ",contr1//TraditionalForm]
        				];
        				If[ contr1=!=0,
            				(newstr = Join[
            				Take[str,{1,sqsL-1}],NCM[Drop[str[[sqsL]],{indL}]],Take[str,{sqsL+1,sqsR-1}],NCM[Drop[str[[sqsR]],{indR}]],Take[str,{sqsR+1,Length[str]}]
            				];
             				If[ SeQuantDebugLevel>=5,
                				 Print["Prefactor: ",(-1)^(iR+indRoff-2)*contr1//TraditionalForm];
                				 Print["Dropped string: ",newstr//TraditionalForm];
                 				 Print["Contracting: ",sqsL," ",indL," ",sqsR," ",indR," iR=",iR," indRoff=",indRoff];
             				];
             				contr2 = contractSQS[newstr,ptype,contractOptions];
            				newcontrib = factorIntoCR[(-1)^(iR+indRoff-2)*contr1,contr2];
             				(* before adding to the result, need to canonizalize if seeking operator rather than full contraction
                			the same term can appear multiple times if fullContract is false, hence must detect such cases reliably
            				 *)
             				If[ !(fullContract/.contractOptions),
                 				newcontrib = orderedForm[newcontrib];
                			 	If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): result (before accumulate) = ",result//TraditionalForm]
                 			 	];
                 			 	If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): newcontrib (before accumulate) = ",newcontrib//TraditionalForm]
                 			 	];
                 				result+=uniqueCR[result,newcontrib];
                 				If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): result (after accumulate) = ",result//TraditionalForm]
                 				];,
                 				result+=newcontrib
             		     	];
             				If[ SeQuantDebugLevel>=5,
                 				Print["contractSQS(",str//TraditionalForm,"): Contracted result: ",contr2//TraditionalForm];
                 				Print["contractSQS(",str//TraditionalForm,"): Total result: ",result//TraditionalForm]
             				];
            				)
        				],
        				{indR,1,Length[str[[sqsR]]]}
        			];
       			 	indRoff+=numIndicesOfType[str[[sqsR]],ptype],
        
        			{sqsR,sL+1,Length[str]}
        		],
        
        		{iL,indLfirst,indLlast}
        	],
        
        	{sL,sqsLfirst,sqsLlast}
        ];
        Return[result];
    ];
contractSQS[NCM[],_particleType,_List] :=
    CR[1,1];
contractSQS[0,_particleType,_List] :=
    0;
(*contractSQS is distributive*)
contractSQS[str_Plus,ptype_particleType,contractOptions_List] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[str];
        Do[result+=contractSQS[str[[i]],ptype,contractOptions],{i,1,nterms}];
        If[ SeQuantDebugLevel>=2,
            Print["contractSQS (Plus): str = ",str//TraditionalForm," ptype = ", ptype," result = ",result//TraditionalForm]
        ];
        Return[result];
    ];
(*separate out prefactors before the contraction*)
(*contractSQS[(a_/;FreeQ[a,SQS])*b_,ptype_particleType,contractOptions_List]:=Module[{result},result=contractSQS[b,ptype,contractOptions];result=CR[a*result[[1]],result[[2]]];Return[result];];*)
contractSQS[str_CR,ptype_particleType,contractOptions_List] :=
    Module[ {result},
        result = contractSQS[str[[2]],ptype,contractOptions];
        result = factorIntoCR[str[[1]],result];
        Return[result];
    ];
(*contracting a single string is easy*)
contractSQS[a_SQS,ptype_particleType,contractOptions_List] :=
    If[ (fullContract/.contractOptions),
        0,
        CR[1,a]
    ];

(*This is a top-level string contraction routine that applies contractions to each particle type*)
contractSQSNTypes[str:NCM[__SQS],contractOptions_List] :=
    Module[ {result,pfac,nstr,ind,ptypes,ntypes,intermedOptions},
        nstr = Length[str];
        ptypes = {};
        Do[
        	ptypes = Append[ptypes,indexTypesSQS[str[[ind]]]],
        	{ind,1,nstr}
        ];
        ptypes = Union[Flatten[ptypes]];
        ntypes = Length[ptypes];

        (*All intermediate contractions are incomplete contractions*)
        intermedOptions = Cases[contractOptions,a_/;FreeQ[a,fullContract]];
        intermedOptions = Append[intermedOptions,fullContract->False];
        result = str;
        Do[
        	result = contractSQS[result,ptypes[[ind]],intermedOptions];
       		If[ SeQuantDebugLevel>=4,
            	Print["Result after ",ind," contractions is: ",result//TraditionalForm]
        	],
        	{ind,1,ntypes-1}
        ];

        (*The last contraction carried according to user's specs*)
        result = contractSQS[result,ptypes[[ntypes]],contractOptions];
        If[ SeQuantDebugLevel>=4,
            Print["Result after the final contraction is: ",result//TraditionalForm]
        ];
        (*Remove CR heads*)
        result = Replace[result,CR->Times,-1,Heads->True];
        If[ SeQuantDebugLevel>=4,
            Print["Normal-looking result after the final contraction is: ",result//TraditionalForm]
        ];
        Return[result];
    ];
contractSQSNTypes[{},_particleType,_List] :=
    1;


(* ::Section:: *)
(* Normal Order *)


(*
   normalOrderedForm[] takes a product of SQSs and returns a (product of) SQS where indices of ptype are collected into one SQS in normal-ordered form.
The result is a CR of the form CR[sign,SQS]
*)

normalOrderedForm[str:NCM[__SQS],ptype_particleType] :=
    Module[ {rstr,indL,permfac},

		(* single string is by definition normal ordered *)
        If[ Length[str]==1,
            Return[CR[1,str[[1]]]]
        ];
        rstr = str;
        permfac = +1;
        (*
          Loop over strings, and move all indices of ptype to the first one
        *)
        (* # of indices of ptype in string 1 *)
        ninds = numIndicesOfType[rstr[[1]],ptype];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: ninds=",ninds]
        ];
        Do[
        	
        
        	ind = firstIndexOfType[rstr[[sL]],ptype];
        	While[ind!=-1,
        		index = rstr[[sL,ind]];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: rstr=",rstr//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: sL=",sL//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: ind=",ind//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: index=",index//TraditionalForm]
        		];

        		(* drop this index from its current string ... *)
        		rstr[[sL]] = Drop[rstr[[sL]],{ind}];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after drop rstr=",rstr//TraditionalForm]
        		];

        		(* move creation indices to the front, move the annihilation indices to the back *)
        		If[ index[[3]]===indexType[cre],
            		rstr[[1]] = Prepend[rstr[[1]],index];
            		permfac*=(-1)^ninds;,
            		rstr[[1]] = Append[rstr[[1]],index];
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after append rstr=",rstr//TraditionalForm]
        		];
        		ninds++;
        		ind = firstIndexOfType[rstr[[sL]],ptype];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after append ind=",ind//TraditionalForm]
        		];
        
        	];
       		If[ SeQuantDebugLevel>=8,
            	Print["in normalOrderedForm: moving on to next substring"]
        	];
        	,{sL,2,Length[rstr]}
        ];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: ready to chomp rstr=",rstr//TraditionalForm]
        ];
        rstr = chomp[rstr];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: after chomp rstr=",rstr//TraditionalForm]
        ];
        Return[CR[permfac,rstr]];
    ];

normalOrderedForm[str_SQS,ptype_particleType] :=
    CR[1,str];

(*
  This function gets rid of empty strings and removes NCM if possible
*)
chomp[str:NCM[__SQS]] :=
    Module[ {rstr},
        rstr = str;

        (* remove empty strings *)
        rstr = Cases[rstr,Except[SQS[]]];
        rstr = rstr/.List->NCM;

        (* if only 1 string left -- remove NCM head *)
        If[ Length[rstr]==1,
            rstr = rstr[[1]]
        ];
        Return[rstr];
    ];


(* ::Section:: *)
(* Wick Class  *)


(*
wick applies Wick's theorem to arbitrary SQ expressions

since SQS do not generally commute with each other the NonCommutativeMultiply (**) has
to be used in such expressions
*)
wick::wrongargs = "Wrong arguments given to wick";
Unprotect[defaultWickOptions];
defaultWickOptions = {
	fullContract->True,
	noCoincidences->False,
	doSums->True,
	doReindex->True
};
Protect[defaultWickOptions];

wick[expr_,extInds_List,wickOptions_List:defaultWickOptions] :=
    Module[ {result,options,intinds,extinds},
        options = Cases[wickOptions,x_/;!FreeQ[x,fullContract]];
        intinds = Sort[indexListOut[expr,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Wick options:"];
            Print[options];
            Print["Internal indices before wick"];
            Print[intinds//TraditionalForm];
        ];
        extinds = Sort[extInds];
        If[ SeQuantDebugLevel>=1,
            Print["External indices:",extinds//TraditionalForm];
        ];
        result = lowwick[expr,options];
        (* New internale indices may have been generatd by lowwick -- recompute *)
        intinds = Sort[indexListOut[result,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Internal indices after wick"];
            Print[intinds//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["Before reduceWick"];
            Print[result//TraditionalForm];
        ];
        If[ doSums/.wickOptions,
            result = reduceWick[result,extinds,intinds]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["After reduceWick"];
            Print[result//TraditionalForm]
        ];
        (* New internale indices may have been generatd by reduceWick -- recompute *)
        intinds = Sort[indexListOut[result,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Internal indices after wick and reduce"];
            Print[intinds//TraditionalForm]
        ];
        If[ noCoincidences/.wickOptions,
            result = result/.x_deltaIndex->0
        ];
        If[ SeQuantDebugLevel>=1,
            Print["Before reindex"];
            Print[result//TraditionalForm];
            Print[intinds//TraditionalForm]
        ];
        If[ doReindex/.wickOptions,
            result = reindex[result,intinds]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["After reindex"];
            Print[result//TraditionalForm]
        ];
        Return[result];
    ];


(* ::Subsection:: *)
(* lowwick funciton *)


(* recursively comupte each term in expression *)
lowwick[a_+b_,contractOptions_List] :=
    Module[ {resulta,resultb},
        resulta = lowwick[a,contractOptions];
        resultb = lowwick[b,contractOptions];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): arg1=",a//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): wick(arg1)=",resulta//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): arg2=",b//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): wick(arg2)=",resultb//TraditionalForm]
        ];
        Return[resulta+resultb]
    ];

lowwick[(a_/;FreeQ[a,SQS])*b_,contractOptions_List] :=
    a*lowwick[b,contractOptions];

(*mtbegin*)
lowwick[a_SQM,contractOptions_List] :=
    a;
(*mtend*)

lowwick[str_SQS,contractOptions_List] :=
    contractSQSNTypes[NCM[str],contractOptions];

lowwick[(str_NCM/;!FreeQ[str,Plus]),contractOptions_List] :=
    Module[ {result,dstr},
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): arg=",str//TraditionalForm]
        ];
        dstr = Map[Distribute,str,{0,Infinity}];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): dist(arg)=",dstr//TraditionalForm]
        ];
        result = lowwick[dstr,contractOptions];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): result=",result//TraditionalForm]
        ];
        Return[result]
    ];

lowwick[str_NCM,contractOptions_List] :=
    Module[ {result,containsSQS,f,i},
        Clear[containsSQS];
        Clear[f];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick: arg=",str//TraditionalForm]
        ];
        pfac = 1;
        result = NCM[];
        f[(a_/;FreeQ[a,SQS])*b_SQS] :=
            (pfac*=a;
             result = Append[result,b]);
        f[(a_/;FreeQ[a,SQS])*b_NCM] :=
            (pfac*=a;
             f[b]);
        f[(a_/;FreeQ[a,SQS])*b_SQM] :=
            (pfac*=a*b);
        f[b_NCM] :=
            (Map[f,b]);
        f[b_SQS] :=
            (result = Append[result,b]);
        f[b_SQM] :=
            (pfac*=b);
        Map[f,str];
        If[ SeQuantDebugLevel>=5,
            Print["in lowwick: fact(arg)=",pfac*result//TraditionalForm]
        ];
        result = If[ result===NCM[],
                     Expand[pfac],
                     Expand[pfac*contractSQSNTypes[result,contractOptions]]
                 ];
        If[ SeQuantDebugLevel>=5,
            Print["in lowwick: wick(arg)=",result//TraditionalForm]
        ];
        Return[result];
    ];


(* ::Subsection:: *)
(* reduceWick *)


(*
Reduction routines

reduceWick is the top-level routine that reduces expressions
    produced by wick by carrying out summations over internalIndices
lowReduceWick is the low-level summation routine
*)
Unprotect[defaultReduceOptions];
defaultReduceOptions = {};
Protect[defaultReduceOptions];

reduceWick[expr_,externalIndices_List:{},internalIndices_List:{},reduceOptions_List:defaultReduceOptions] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[expr];
        If[ Head[expr]===Plus,
            result = 0;
            Do[
            	GlobalIndexCounter = 0;
            	result+=lowReduceWick[expr[[i]],externalIndices,internalIndices,reduceOptions],{i,1,nterms}
            ],
            result = lowReduceWick[expr,externalIndices,internalIndices,reduceOptions]
        ];
        Return[result];
    ];

lowReduceWick[expr_,externalIndices_List,internalIndices_List,reduceOptions_List] :=
    Module[ {deltaReplInt,deltaReplExtA,deltaReplExtB,result,indI,indJ,spaceI,spaceJ,indK,extI,ipairIJ,havedeltaIJ,havedeltaJI},
        deltaReplInt = {};
        deltaReplExtA = {};
        deltaReplExtB = {};
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: expr = ",expr//TraditionalForm];
            Print["In lowReduceWick: internalIndices = ",internalIndices//TraditionalForm];
        ];

        (* Reducing Kronecker delta's uses 2 rules:
        1) if it binds 2 internal (summed-over) indices I and J, replace them with a new internal index representing intersection of spaces of I and J, !!remove delta!!
        2) if it binds an internal (summed-over) index J and external index I:
        2a) if space of J includes space of I, replace J with I, !!remove delta!!
        2b) If space of J is a subset of space of I, replace J with a new internal index represenating intersection of spaces of I and J, !!keep the delta!!
        *)
        Do[
        	indI = internalIndices[[intI]];
        	spaceI = indexSpace[indI];
        	Do[
        		indJ = internalIndices[[intJ]];
        		spaceJ = indexSpace[indJ];
        		havedeltaIJ = deltaQ[expr,deltaIndex[indI,indJ]];
        		havedeltaJI = deltaQ[expr,deltaIndex[indJ,indI]];
        		If[ !havedeltaIJ&&!havedeltaJI,
           	 		Continue[]
        		];
        		spaceK = Intersection[spaceI,spaceJ];
        		If[ spaceI===spaceK,
            		indK = indI,
            		If[ spaceJ===spaceK,
                		indK = indJ,
                		indK = createParticleIndex[spaceK]
            		]
        		];
        		pairIJ = {indK,indI,indJ};
        		deltaReplInt = Append[deltaReplInt,pairIJ];
        		,
        		{intJ,intI+1,Length[internalIndices]}
        	],
        	{intI,1,Length[internalIndices]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick:  int-int delta replacement = ",deltaReplInt//TraditionalForm];
        ];
        Do[
        	indI = externalIndices[[extI]];
        	spaceI = indexSpace[indI];
        	Do[
        		indJ = internalIndices[[intJ]];
        		spaceJ = indexSpace[indJ];
        		havedeltaIJ = deltaQ[expr,deltaIndex[indI,indJ]];
        		havedeltaJI = deltaQ[expr,deltaIndex[indJ,indI]];
        		If[ !havedeltaIJ&&!havedeltaJI,
            		Continue[]
        		];
        		spaceK = Intersection[spaceI,spaceJ];
        		paceK = Intersection[spaceI,spaceJ];
        		If[ spaceI===spaceK,
            		indK = indI,
            		If[ spaceJ===spaceK,
                		indK = indJ,
                		indK = createParticleIndex[spaceK]
            		]
        		];
        		pairIJ = {indK,indI,indJ};
       		 	If[ spaceI===spaceK,
            		deltaReplExtA = Append[deltaReplExtA,pairIJ],
            		deltaReplExtB = Append[deltaReplExtB,pairIJ]
        		];
        		,
        		{intJ,1,Length[internalIndices]}
        	],
        	{extI,1,Length[externalIndices]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick:  ext-in-int delta replacement = ",deltaReplExtA//TraditionalForm];
            Print["In lowReduceWick:  ext-int delta replacement = ",deltaReplExtB//TraditionalForm];
        ];
        result = expr;
        Do[
        	indK = deltaReplInt[[i,1]];
        	indI = deltaReplInt[[i,2]];
        	indJ = deltaReplInt[[i,3]];
        	result = result/.deltaIndex[a_,b_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.deltaIndex[b_,a_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplInt]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after int-int reduction: result = ",result//TraditionalForm];
        ];
        Do[
        	indK = deltaReplExtA[[i,1]];
        	indI = deltaReplExtA[[i,2]];
        	indJ = deltaReplExtA[[i,3]];
        	result = result/.deltaIndex[a_,b_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.deltaIndex[b_,a_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplExtA]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after ext-in-int reduction: result = ",result//TraditionalForm];
        ];
        Do[
        	indK = deltaReplExtB[[i,1]];
        	indI = deltaReplExtB[[i,2]];
        	indJ = deltaReplExtB[[i,3]];
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplExtB]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after ext-int reduction: result = ",result//TraditionalForm];
        ];
        Return[result];
    ];


(*
Transformation routines

orderedForm puts elements of SQ expressions (SQ strings SQS and matrix elements SQM) into their "canonical " form. The canonical order of indices of each type (that belong to the same space) is alphabetical. This is where the permutational symmetry of SQM's matters.
*)
orderedForm[a_**b_,intInds_List:{}] :=
    orderedForm[a,intInds]**orderedForm[b,intInds];
orderedForm[a_*b_,intInds_List:{}] :=
    orderedForm[a,intInds]*orderedForm[b,intInds];
orderedForm[a_+b_,intInds_List:{}] :=
    orderedForm[a,intInds]+orderedForm[b,intInds];
orderedForm[a_^n_,intInds_List:{}] :=
    orderedForm[a,intInds]^n;
orderedForm[a_?NumberQ,intInds_List:{}] :=
    a;
orderedForm[x_deltaIndex,intInds_List:{}] :=
    x;
orderedForm[x_CR,intInds_List:{}] :=
    CR[orderedForm[x[[1]],intInds],orderedForm[x[[2]],intInds]];

orderedForm[str_SQS,intInds_List:{}] :=
    Module[ {result,permfac,creInds,annInds},
        permfac = 1;
        compareInds[a_,b_] :=
            Order[a[[1]],b[[1]]];
        creInds = Cases[str,a_particleIndex/;a[[3]]==indexType[cre]];
        permfac*=Signature[creInds];
        creInds = Sort[creInds];
        annInds = Cases[str,a_particleIndex/;a[[3]]==indexType[ann]];
        annInds = Reverse[annInds];
        permfac*=Signature[annInds];
        annInds = Sort[annInds];
        result = permfac*FlattenAt[SQS[FlattenAt[{creInds,Reverse[annInds]},{{1},{2}}]],{1}];
        Return[result];
    ];

orderedForm[oper_SQM,intInds_List:{}] :=
    Module[ {result,symfac,permfac,operHead,braInds,ketInds},
        symfac = Cases[oper,_indexSymm,Infinity][[1,1]];
        If[ symfac==0,
            Return[oper]
        ];
        permfac = 1;
        operHead = Cases[oper,_OHead][[1]];
        compareInds[a_,b_] :=
            Order[a[[1]],b[[1]]];
        result = oper;

        (* 
        canonical order prioritizes external indices over internal
        to achieve this tag all internal indices such that their Length is greater, then external indices will come first
        *)
        result = tagIndices[oper,intInds];
        braInds = Cases[result,a_particleIndex/;a[[3]]==indexType[bra]];
        If[ symfac==-1,
            permfac*=Signature[braInds]
        ];
        braInds = Sort[braInds];
        ketInds = Cases[result,a_particleIndex/;a[[3]]==indexType[ket]];
        If[ symfac==-1,
            permfac*=Signature[ketInds]
        ];
        ketInds = Sort[ketInds];
        result = FlattenAt[SQM[FlattenAt[{braInds,ketInds},{{1},{2}}]],{1}];
        result = Prepend[result,operHead];
        result*=permfac;
        result = untagIndices[result,intInds];
        Return[result];
    ];


(* low-level function that produces the list of unique indices from expr which are present in intInds *)
indexListIn[expr_,intInds_List] :=
    Module[ {intIndsIn},
        intIndsIn = {};
        Do[
        	If[ indexQ[expr,intInds[[i]] ]&&!indexQ[intIndsIn,intInds[[i]]],
            	intIndsIn = Append[intIndsIn,intInds[[i]]]
        	],
        	{i,1,Length[intInds]}
        ];
        Return[intIndsIn];
    ];

(* low-level function that produces the list of unique indices from expr which are not present in intInds *)
indexListOut[expr_,intInds_List] :=
    Module[ {indsOut,indsAll,a},
        indsOut = {};
        indsAll = Cases[expr,x_particleIndex,Infinity];
        Do[
        	a = indsAll[[i]];
        	If[ !indexQ[intInds,a]&&!indexQ[indsOut,a],
            	indsOut = Append[indsOut,a]
        	],
        	{i,1,Length[indsAll]}
        ];
        Return[indsOut];
    ];


(* ::Section:: *)
(* Reindexing  *)


(*
Reindexing routines

reindex is the top-level reindexing routine
lowreindex is the low-level routine
*)
reindex[expr_,intInds_List:{}] :=
    Module[ {result,ordexpr,tmpexpr,i},
        result = 0;

(* If result is a constant -- no need to reindex *)
        If[ FreeQ[expr,SQM]&&FreeQ[expr,SQS],
            Return[expr]
        ];

        (* Put SQS's and SQM's in expr into their canonical form *)
        ordexpr = orderedForm[expr,intInds];

        (* Reorder SQS's and SQM's

        Times orders expressions automatically according to the canonical order

        The canonical order that we want is determined by external indices only  so that
        the subsequent call to lowreindex can
        simplify results the most.
        *)
        (* Replace Times with NCM and reorder into "new " canonical order*)
        ordexpr = ordexpr/.Times->NCM;
        (*Print["Before new canon ord"];
        Print[ordexpr//TraditionalForm];*)
        tmpexpr = 0;
        If[ Head[ordexpr]===Plus,
            Do[tmpexpr+=newcanonord[ordexpr[[i]],intInds],{i,Length[ordexpr]}],
            tmpexpr = newcanonord[ordexpr,intInds]
        ];
        ordexpr = tmpexpr;
        (*Print["In new canon ord"];
        Print[ordexpr//TraditionalForm];*)

        (*
        Rename internal indices using the canonical list for each index space

        Right now there's no additional reordering of internal indices prior to reindexing. This should be OK
        as long as no 6-index quantities appear in the expression. If that happens then as additional reordering
        of internal indices needs to be performed. The algorithms for that is as follows:
        1. within each SQS/SQM order internal indices which appear in the expression for the first time according to the index of the SQS/SQM in which this index appears next. If multiple internal indices from the current SQS/SQM appear in a nonsymmetric SQM later in the expression, order is determined by the relative position of the indices in that SQM.

        I think what I do now is OK if no 3-body operators or excitations are considered.
        *)
        If[ Head[ordexpr]===Plus,
            Do[result+=lowreindex[ordexpr[[i]],intInds],{i,Length[ordexpr]}],
            result = lowreindex[ordexpr,intInds]
        ];
        (*Print["After lowreindex"];
        Print[result//TraditionalForm];*)

        (* NCM can be changed back to Times now *)
        result = result/.NCM->Times;

        (* In case some SQS's or SQM's are not canonicalized - canonicalize again *)
        result = orderedForm[result,intInds];
        Return[result];
    ];

lowreindex[expr_,intInds_List] :=
    Module[ {result,transexpr,indexlist,canonord,pairlist,ind,space,i},
        If[ Length[intInds]==0,
            Return[expr]
        ];
        (* Form canonically ordered lists *)
        Do[
        	ind = intInds[[i]];
        	space = Cases[intInds[[i]],_particleSpace][[1]];
        	If[ Head[canonord[space]]=!=List,
            	canonord[space] = {}
        	];
        	If[ !MemberQ[canonord[space],ind],
            	canonord[space] = Append[canonord[space],ind]
        	],
        	{i,Length[intInds]}
        ];

       	(* Transform layout of SQS's so that the grand index list is pretty; we want external indices to come first in creation list, but last in the annihilation list
        *)
        If[ Head[expr]=!=SQS&&!FreeQ[expr,SQS],(*transexpr=Cases[expr,x_SQS:>FlattenAt[SQS[FlattenAt[{Level[Select[x,indexCreQ],1],Reverse[Level[Select[x,indexAnnQ] ,1]]},{{1},{2}}]],{1}]]*)
            transexpr = expr/.x_SQS:>FlattenAt[SQS[FlattenAt[{Level[Select[x,indexCreQ],1],Reverse[Level[Select[x,indexAnnQ] ,1]]},{{1},{2}}]],{1}],
            transexpr = expr
        ];
        If[ Head[expr]===SQS,
            transexpr = FlattenAt[SQS[FlattenAt[{Level[Select[expr,indexCreQ],1],Reverse[Level[Select[expr,indexAnnQ] ,1]]},{{1},{2}}]],{1}]
        ];

        (* Get the grand list of all indices in the expression *)
        indexlist = Cases[transexpr,x_particleIndex,Infinity];

        (* For each internal index in indexlist find its canonicalized counterpart and form the list of (old,new) pairs *)
        pairlist = {};
        tmpintinds = intInds;
        If[ SeQuantDebugLevel>=2,
            (
           	Print["In lowreindex: transformed expression = ",transexpr//TraditionalForm];
            Print["In lowreindex: grand index list = ",indexlist//TraditionalForm];
            Print["In lowreindex: internal index list = ",intInds//TraditionalForm]
            )
        ];
        Do[
        	ind = indexlist[[i]];
        	space = indexSpace[ind];
        	If[ indexQ[tmpintinds,ind],
            	(If[ !indexEquiv[ind,canonord[space][[1]]],
                 	pairlist = Append[pairlist,{createParticleIndex[ind[[1]],ind[[2]]],canonord[space][[1]]}]
             	];
             	canonord[space] = Drop[canonord[space],1];
             	tmpintinds = DeleteCases[tmpintinds,x_particleIndex/;indexEquiv[x,ind],Infinity]
            	)
       		 ],
        	{i,Length[indexlist]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowreindex: internal index replacement list = ",pairlist]
        ];

        (* Use pairlist to replace indices *)
        result = expr;
        Do[
        	indI = pairlist[[i,1]];
        	indJ = pairlist[[i,2]];
        	(* Replacement in deltaIndex and in SQM/SQS work slightly differently *)
        	result = result/.indII_particleIndex:>particleIndex[indJ[[1]],indJ[[2]],indII[[3]],"newIndex"]/;(Length[indII]>2&&FreeQ[indII,"newIndex"]&&(indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	result = result/.indII_particleIndex:>particleIndex[indJ[[1]],indJ[[2]],"newIndex"]/;(Length[indII]==2&&FreeQ[indII,"newIndex"]&&(indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	,{i,1,Length[pairlist]}
        ];

        (* get rid of temporary "newIndex " tags on replaced indices *)
        result = result/.indII_particleIndex:>particleIndex[indII[[1]],indII[[2]]]/;(Length[indII]==3&&!FreeQ[indII,"newIndex"]);
        result = result/.indII_particleIndex:>particleIndex[indII[[1]],indII[[2]],indII[[3]]]/;(Length[indII]>3&&!FreeQ[indII,"newIndex"]);
        Return[result];
    ];

newcanonord[0, _List] :=
    0;
newcanonord[expr_SQS|expr_SQM,intInds_List] :=
    expr;
newcanonord[expr_NCM,intInds_List] :=
    Module[ {neword,tmpexpr,reordlist,i},
(*
Put elements that contain external indices at the beginning. If two elements
contain same number of external indices order according to the standard Order[] 

This strategy will only work in simple cases
*)
        tmpexpr = expr/.a_particleIndex:>1/;indexQ[intInds,a];
        neword[a_,b_] :=
            Module[ {result,na,nb},
                na = Length[Cases[a,x_particleIndex/;!indexQ[intInds,x]]];
                nb = Length[Cases[b,x_particleIndex/;!indexQ[intInds,x]]];
                result = If[ na>nb,
                             True,
                             If[ na<nb,
                                 False,
                                 Order[a,b]>=0
                             ]
                         ];
                Return[result];
            ];
        reordlist = Ordering[tmpexpr,Length[tmpexpr],neword];
        tmpexpr = expr[[ reordlist[[1]] ]];
        Do[tmpexpr = tmpexpr**expr[[ reordlist[[i]] ]],{i,2,Length[reordlist]}];
        Return[tmpexpr];
    ];


(*
Remove diconnected terms. Connectedness is determined with respect to the Hamiltonian
*)

removeDisconnectedTerms[expr_,externalIndices_List:{},hamiltonianOpers_List:defaultHamiltonianOpers] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[expr];
        If[ Head[expr]===Plus,
            result = 0;
            Do[
            GlobalIndexCounter = 0;
            result+=lowRemoveDisconnectedTerms[expr[[i]],externalIndices,hamiltonianOpers],{i,1,nterms}],
            result = lowRemoveDisconnectedTerms[expr,externalIndices,hamiltonianOpers]
        ];
        Return[result];
    ];

	
lowRemoveDisconnectedTerms[expr_,externalIndices_List,hamiltonianOpers_List] :=
    Module[ {intIndices,SQMs,tags,itag,dist,nsqm,hindex,nh,dists,result,listcopy,done,connected},
(* If there are no SQMs, there are no disconnected terms *)
        If[ FreeQ[expr,SQM],
            Return[expr]
        ];
        intIndices = indexListOut[expr,externalIndices];
        SQMs = getSQMList[expr];
        (* ignore some operators if need the rest to be fully connected *)
        SQMs = Select[SQMs,Count[ignoreConnectedOpers,#[[1,1]]]==0&];
        nsqm = Length[SQMs];
        tags = Table[False,{i,1,nsqm}];
        nh = Length[hamiltonianOpers];
        (* find the hamiltonian matrix element *)
        hindex = -1;
        Do[
        Do[
        If[ SQMs[[m,1,1]]==hamiltonianOpers[[h]],
            hindex = m;
            Break
        ]
        ,{m,1,nsqm}
        ];
        If[ hindex!=-1,
            Break
        ],
        {h,1,nh}
        ];
        If[ hindex==-1,
            Print["SeQuant Abort: lowRemoveDisconnectedTerms: Hamiltonian operator is not found"];
            Abort[]
        ];
        listcopy = SQMs;
        done = 0;
        (* tag indices recursively starting with h until all exhausted *)
        itag = hindex;
        ariadna = {}; (* keeps track of the path from the hamiltonian *)
        While[done==0,
        result = tagSQMInList[itag,listcopy,tags,intIndices];
        If[ Length[result]==3,
        (*Print["Result=",result//TraditionalForm];*)
            ariadna = Append[ariadna,itag];
            itag = result[[1]];
            listcopy = result[[2]];
            tags = result[[3]]
        ];
        If[ Length[result]==2,
        (*Print["Result=",result//TraditionalForm];*)
            tags = result[[2]];
            done = 1
        ];
        (*Print["Ariadna=",ariadna];*)
        If[ result==-1,
            done = 1
        ];
        (* If current node not connected to other untagged nodes, step back along the thread towards h,unless just started from h (dist==0) *)
        If[ done==1&&Length[ariadna]!=0,
            itag = Last[ariadna];
            ariadna = Drop[ariadna,-1];
            done = 0
        ];
        ];
        (* if some nodes are on the ignore list, tag them *)
        Do[If[ tags[[o]]==False&&Count[ignoreDisconnectedOpers,SQMs[[o,1,1]]]>0,
               tags[[o]] = True
           ],{o,1,nsqm}];
        noTags = Select[tags,#==False&];
        If[ Length[noTags]==0,
            Return[expr],
            Return[0]
        ];
    ];

getSQMList[expr_] :=
    Module[ {flatexpr,result},
        flatexpr = Flatten[expr];
        (* much simpler if the expression is an SQM itself *)
        If[ Head[flatexpr]===SQM,
            result = {flatexpr},
            result = Select[flatexpr,Head[#]==SQM&];
            (* for some reason Select may discard Head, e.g. when expr = Times[-1,SQM[OHead["F",indexSymm[-1]],particleIndex["\!\(a\_r\)",particleSpace[virtual],indexType[bra]],particleIndex["\!\(i\_r\)",particleSpace[occupied],indexType[ket]]]] *)
            result = If[ Head[result]===SQM,
                         {result},
                         result
                     ];
            result = Replace[result,Times->List,-1,Heads->True]
        ];
        Return[result];
    ];

tagSQMInList[icurr_,SQMs_List,Tags_List,IIndices_List] :=
    Module[ {nsqm,inext,ninds,current,iinds,niinds,iind,j,k,result,localtags,inList},
(*Print["Will tag element ",icurr," in list ",SQMs//TraditionalForm," current tags are ",Tags];*)
        nsqm = Length[SQMs];
        current = SQMs[[icurr]];
        ninds = Length[current]-1;
        iinds = {};
        (* Find all internal indices connecting current SQM *)
        Do[
        j = current[[k+1]];
        If[ indexQ[IIndices,j],
            iinds = Append[iinds,j]
        ]
        ,{k,1,ninds}
        ];
        niinds = Length[iinds];
        localtags = Tags;
        localtags[[icurr]] = True;
        result = -1;
        (* Find an untagged SQM connected to i using index iind *)
        Do[
        If[ result!=-1,
            Break
        ];
        iind = iinds[[j]];
        Do[
        If[ k!=icurr,
            If[ indexQ[SQMs[[k]],iind],
                If[ localtags[[k]]==False,
                    inext = k;
                    localtags[[k]]==True;
                    result = {inext,SQMs,localtags};
                    Break;
                ]
            ]
        ]
        ,{k,1,nsqm}
        ],
        {j,1,niinds}
        ];
        If[ result==-1,
            result = {-1,localtags}
        ];
        Return[result];
    ];


(* ::Section:: *)
(* matching SQ *)


(*
Functions for pattern matching SQ expressions
*)

Unprotect[MatchQ];

MatchQ[a_particleIndex,b_particleIndex] :=
    Module[ {lb,result},
        lb = Length[b];
        result = True;
        Do[
        If[ Head[b[[i]]]=!=String,
            result = result &&!FreeQ[a,b[[i]]]
        ],
        {i,lb}
        ];
        Return[result];
    ];

MatchQ[a_SQS,b_SQS] :=
    Module[ {lb,result},
        lb = Length[b];
        If[ lb!=Length[a],
            Return[False]
        ];
        result = True;
        Do[
        result = result &&MatchQ[a[[i]],b[[i]]],
        {i,lb}
        ];
        Return[result];
    ];

MatchQ[a_SQM,b_SQM] :=
    Module[ {lb,result},
        lb = Length[b];
        If[ lb!=Length[a],
            Return[False]
        ];
        result = True;
        Do[
        If[ Head[b[[i]]]===OHead&&b[[i,1]]==="_",
            result = result&&True,
            result = result &&MatchQ[a[[i]],b[[i]]]
        ],
        {i,lb}
        ];
        Return[result];
    ];

(* Match SQ expressions *)
MatchQ[a_Times,b_Times] :=
    listMatchQ[ReplacePart[a,List,0],ReplacePart[b,List,0]];
MatchQ[a_Times,b_SQM] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_Times,b_SQS] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_NCM,b_NCM] :=
    listMatchQ[ReplacePart[a,List,0],ReplacePart[b,List,0]];
MatchQ[a_NCM,b_SQM] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_NCM,b_SQS] :=
    itemMatchQ[ReplacePart[a,List,0],b];

listMatchQ[a_List,b_List] :=
    Module[ {af,bf,lb,result},
        If[ Length[b]==0,
            Return[True]
        ];
        (*af=Flatten[a];
        bf=Flatten[b];*)
        af = a;
        bf = b;
        lb = Length[bf];
        Print[Length[af]," ",lb];
        If[ lb>Length[af],
            Return[False]
        ];
        pos = Position[af,x_/;MatchQ[x,bf[[1]]],{0,Infinity},1];
        result = True;
        If[ pos=={},
            result = False,
            af = Delete[af,pos[[1]]];
            bf = Delete[bf,1];
            Print[af," ",bf];
            Print[Head[af],Head[bf]];
            result = MatchQ[af,bf];
        ];
        Return[result];
    ];

Protect[MatchQ];


(* ::Section:: *)
(* canonical MO *)


(*
Transform expressions assuming canonical MOs
NOTE: canonical MOs imply Brilluoin theorem
*)
canonMO[expr_,extInds_List] :=
    Module[ {result,intinds,extinds},
        intinds = Sort[indexListOut[expr,extInds]];
        extinds = Sort[extInds];
        result = brillouin[expr];
        result = lowcanonMO[result];
        result = reduceWick[result,extinds,intinds];
        result = orderedForm[result,intinds];
        Return[result];
    ];

lowcanonMO[expr_] :=
    Module[ {result,v,o,a,fvv,foo,faa,fock},
        v = createParticleIndex["_",virt];
        o = createParticleIndex["_",occ];
        a = createParticleIndex["_",any];
        fock = defaultHamiltonianOpers[[1]];
        fvv = createSQM[fock,{v},{v},antisymm];
        foo = createSQM[fock,{o},{o},antisymm];
        faa = createSQM[fock,{a},{a},antisymm];
        result = expr;
        (*result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,foo];
        result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,fvv];
        result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,faa];*)
        result = result/.a_SQM:>(deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm])/;MatchQ[a,foo];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,fvv];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,faa];
        Return[result];
    ];

(*
Transform expressions assuming different versions of Brillouin theorem
*)
brillouin[expr_] :=
    Module[ {result,v,o,fvo,fov,fock},
        v = createParticleIndex["_",virt];
        o = createParticleIndex["_",occ];
        fock = defaultHamiltonianOpers[[1]];
        fvo = createSQM[fock,{v},{o},antisymm];
        fov = createSQM[fock,{o},{v},antisymm];
        result = expr;
        result = result/.a_SQM:>0/;MatchQ[a,fov];
        result = result/.a_SQM:>0/;MatchQ[a,fvo];
        Return[result];
    ];

(* includes standard Brillouin theorem *)
brillouinGen[expr_] :=
    Module[ {result,\[Alpha],o,f\[Alpha]o,fo\[Alpha],fock},
        \[Alpha] = createParticleIndex["_",allvirt];
        o = createParticleIndex["_",occ];
        fock = defaultHamiltonianOpers[[1]];
        f\[Alpha]o = createSQM[fock,{\[Alpha]},{o},antisymm];
        fo\[Alpha] = createSQM[fock,{o},{\[Alpha]},antisymm];
        result = expr;
        result = result/.a_SQM:>0/;MatchQ[a,fo\[Alpha]];
        result = result/.a_SQM:>0/;MatchQ[a,f\[Alpha]o];
        Return[result];
    ];

brillouinExt[expr_] :=
    Module[ {result,\[Alpha],v,f\[Alpha]v,fv\[Alpha],fock},
        \[Alpha] = createParticleIndex["_",allvirt];
        v = createParticleIndex["_",virt];
        fock = defaultHamiltonianOpers[[1]];
        f\[Alpha]v = createSQM[fock,{\[Alpha]},{v},antisymm];
        fv\[Alpha] = createSQM[fock,{v},{\[Alpha]},antisymm];
        result = expr;
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,fv\[Alpha]];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[3]] ]},{indexLight[ a[[3]] ]},antisymm]/;MatchQ[a,f\[Alpha]v];
        Return[result];
    ];

(*
Substitutes a second quantized tensor by the corresponding density matrix element.
*)
substituteSQSbyDensity[expr_] :=
    expr/.x_SQS->createSQM["\[Gamma]",annIndices[x],creIndices[x],antisymm];

(*
Zeroes out density matrix elements that include indices above the Fermi level
*)
zeroDensity[expr_] :=
    expr/.x_SQM/;x[[1,1]]=="\[Gamma]" &&
    MemberQ[x,y_particleIndex/;spaceWRTFermiLevel[indexSpace[y]]===+1]->0

(* toolkit is ready *)
Print["SeQuant is loaded and ready...\n"];
(*EndPackage[]*)



